class CanvasImage { constructor(t) { this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), document.body.appendChild(this.canvas), this.width = this.canvas.width = t.width, this.height = this.canvas.height = t.height, this.context.drawImage(t, 0, 0, this.width, this.height) } clear() { this.context.clearRect(0, 0, this.width, this.height) } update(t) { this.context.putImageData(t, 0, 0) } getPixelCount() { return this.width * this.height } getImageData() { return this.context.getImageData(0, 0, this.width, this.height) } removeCanvas() { this.canvas.parentNode.removeChild(this.canvas) } } class ColorThumbs { getHexThumbs(t, r, e) { return this.getPalette(t, r, e).map(t => `#${t.map(t => parseInt(t).toString(16)).join("")}`) } getPalette(t, r, e) { (void 0 === r || r < 2 || r > 256) && (r = 10), (void 0 === e || e < 1) && (e = 10); const n = new CanvasImage(t), o = n.getImageData().data, a = n.getPixelCount(), s = []; for (let t, r, n, i, u, h = 0; h < a; h += e)r = o[(t = 4 * h) + 0], n = o[t + 1], i = o[t + 2], (u = o[t + 3]) >= 125 && (r > 250 && n > 250 && i > 250 || s.push([r, n, i])); const i = MMCQ.quantize(s, r), u = i ? i.palette() : null; return n.removeCanvas(), u } getImageData(t, r) { xhr = new XMLHttpRequest, xhr.open("GET", t, !0), xhr.responseType = "arraybuffer", xhr.onload = function (t) { if (200 == this.status) { uInt8Array = new Uint8Array(this.response), e = uInt8Array.length, binaryString = new Array(e); for (var e = 0; e < uInt8Array.length; e++)binaryString[e] = String.fromCharCode(uInt8Array[e]); data = binaryString.join(""), base64 = window.btoa(data), r(`data:image/png;base64,${base64}`) } }, xhr.send() } }if (!pv) var pv = { map: function (t, r) { var e = {}; return r ? t.map(function (t, n) { return e.index = n, r.call(e, t) }) : t.slice() }, naturalOrder: function (t, r) { return t < r ? -1 : t > r ? 1 : 0 }, sum: function (t, r) { var e = {}; return t.reduce(r ? function (t, n, o) { return e.index = o, t + r.call(e, n) } : function (t, r) { return t + r }, 0) }, max: function (t, r) { return Math.max.apply(null, r ? pv.map(t, r) : t) } }; var MMCQ = (() => { var t = 5, r = 8 - t, e = 1e3, n = .75; function o(r, e, n) { return (r << 2 * t) + (e << t) + n } function a(t) { var r = [], e = !1; function n() { r.sort(t), e = !0 } return { push(t) { r.push(t), e = !1 }, peek: t => (e || n(), void 0 === t && (t = r.length - 1), r[t]), pop: () => (e || n(), r.pop()), size: () => r.length, map: t => r.map(t), debug: () => (e || n(), r) } } class s { constructor(t, r, e, n, o, a, s) { this.r1 = t, this.r2 = r, this.g1 = e, this.g2 = n, this.b1 = o, this.b2 = a, this.histo = s } volume(t) { const r = this; return r._volume && !t || (r._volume = (r.r2 - r.r1 + 1) * (r.g2 - r.g1 + 1) * (r.b2 - r.b1 + 1)), r._volume } count(t) { const r = this, e = r.histo; if (!r._count_set || t) { let t, n, a, s, i = 0; for (n = r.r1; n <= r.r2; n++)for (a = r.g1; a <= r.g2; a++)for (s = r.b1; s <= r.b2; s++)i += e[t = o(n, a, s)] || 0; r._count = i, r._count_set = !0 } return r._count } copy() { return new s(this.r1, this.r2, this.g1, this.g2, this.b1, this.b2, this.histo) } avg(r) { const e = this, n = e.histo; if (!e._avg || r) { let r = 0; const a = 1 << 8 - t; let s, i, u, h, c, v = 0, l = 0, g = 0; for (i = e.r1; i <= e.r2; i++)for (u = e.g1; u <= e.g2; u++)for (h = e.b1; h <= e.b2; h++)r += s = n[c = o(i, u, h)] || 0, v += s * (i + .5) * a, l += s * (u + .5) * a, g += s * (h + .5) * a; e._avg = r ? [~~(v / r), ~~(l / r), ~~(g / r)] : [~~(a * (e.r1 + e.r2 + 1) / 2), ~~(a * (e.g1 + e.g2 + 1) / 2), ~~(a * (e.b1 + e.b2 + 1) / 2)] } return e._avg } contains(t) { const e = t[0] >> r; return gval = t[1] >> r, bval = t[2] >> r, e >= this.r1 && e <= this.r2 && gval >= this.g1 && gval <= this.g2 && bval >= this.b1 && bval <= this.b2 } } class i { constructor() { this.vboxes = new a((t, r) => pv.naturalOrder(t.vbox.count() * t.vbox.volume(), r.vbox.count() * r.vbox.volume())) } push(t) { this.vboxes.push({ vbox: t, color: t.avg() }) } palette() { return this.vboxes.map(t => t.color) } size() { return this.vboxes.size() } map(t) { const r = this.vboxes; for (let e = 0; e < r.size(); e++)if (r.peek(e).vbox.contains(t)) return r.peek(e).color; return this.nearest(t) } nearest(t) { const r = this.vboxes; let e, n, o; for (let a = 0; a < r.size(); a++)((n = Math.sqrt((t[0] - r.peek(a).color[0]) ** 2 + (t[1] - r.peek(a).color[1]) ** 2 + (t[2] - r.peek(a).color[2]) ** 2)) < e || void 0 === e) && (e = n, o = r.peek(a).color); return o } forcebw() { const t = this.vboxes; t.sort((t, r) => pv.naturalOrder(pv.sum(t.color), pv.sum(r.color))); const r = t[0].color; r[0] < 5 && r[1] < 5 && r[2] < 5 && (t[0].color = [0, 0, 0]); const e = t.length - 1, n = t[e].color; n[0] > 251 && n[1] > 251 && n[2] > 251 && (t[e].color = [255, 255, 255]) } } function u(t, r) { if (r.count()) { var e = r.r2 - r.r1 + 1, n = r.g2 - r.g1 + 1, a = r.b2 - r.b1 + 1, s = pv.max([e, n, a]); if (1 == r.count()) return [r.copy()]; var i, u, h, c, v = 0, l = [], g = []; if (s == e) for (i = r.r1; i <= r.r2; i++) { for (c = 0, u = r.g1; u <= r.g2; u++)for (h = r.b1; h <= r.b2; h++)c += t[o(i, u, h)] || 0; v += c, l[i] = v } else if (s == n) for (i = r.g1; i <= r.g2; i++) { for (c = 0, u = r.r1; u <= r.r2; u++)for (h = r.b1; h <= r.b2; h++)c += t[o(u, i, h)] || 0; v += c, l[i] = v } else for (i = r.b1; i <= r.b2; i++) { for (c = 0, u = r.r1; u <= r.r2; u++)for (h = r.g1; h <= r.g2; h++)c += t[o(u, h, i)] || 0; v += c, l[i] = v } return l.forEach((t, r) => { g[r] = v - t }), p(s == e ? "r" : s == n ? "g" : "b") } function p(t) { var e, n, o, a, s, u = t + "1", h = t + "2", c = 0; for (i = r[u]; i <= r[h]; i++)if (l[i] > v / 2) { for (o = r.copy(), a = r.copy(), s = (e = i - r[u]) <= (n = r[h] - i) ? Math.min(r[h] - 1, ~~(i + n / 2)) : Math.max(r[u], ~~(i - 1 - e / 2)); !l[s];)s++; for (c = g[s]; !c && l[s - 1];)c = g[--s]; return o[h] = s, a[u] = o[h] + 1, [o, a] } } } return { quantize: function (h, c) { if (!h.length || c < 2 || c > 256) return !1; var v = function (e) { var n, a, s, i, u = new Array(1 << 3 * t); return e.forEach(t => { a = t[0] >> r, s = t[1] >> r, i = t[2] >> r, n = o(a, s, i), u[n] = (u[n] || 0) + 1 }), u }(h); v.forEach(() => { }); var l = function (t, e) { var n, o, a, i = 1e6, u = 0, h = 1e6, c = 0, v = 1e6, l = 0; return t.forEach(t => { n = t[0] >> r, o = t[1] >> r, a = t[2] >> r, n < i ? i = n : n > u && (u = n), o < h ? h = o : o > c && (c = o), a < v ? v = a : a > l && (l = a) }), new s(i, u, h, c, v, l, e) }(h, v), g = new a((t, r) => pv.naturalOrder(t.count(), r.count())); function p(t, r) { for (var n, o = 1, a = 0; a < e;)if ((n = t.pop()).count()) { var s = u(v, n), i = s[0], h = s[1]; if (!i) return; if (t.push(i), h && (t.push(h), o++), o >= r) return; if (a++ > e) return } else t.push(n), a++ } g.push(l), p(g, n * c); for (var f = new a((t, r) => pv.naturalOrder(t.count() * t.volume(), r.count() * r.volume())); g.size();)f.push(g.pop()); p(f, c - f.size()); for (var b = new i; f.size();)b.push(f.pop()); return b } } })(); export default ColorThumbs;